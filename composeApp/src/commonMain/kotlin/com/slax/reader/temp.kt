package com.slax.reader

val htmlData = """
<div class="page" id="readability-page-1"><div id="js_content"><p></p><section><span leaf=""><img loading="lazy" style="width: 140px !important;" data-imgfileid="100025598" data-ratio="0.3037037037037037" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh4ek0GU1Snpd5xyiahZAUvz7OBtgIlbTu6EPpyEfG6V2kESjkXKK3fSHP6voC8hyCcn0RXhCkB2dicg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-index="1" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh4ek0GU1Snpd5xyiahZAUvz7OBtgIlbTu6EPpyEfG6V2kESjkXKK3fSHP6voC8hyCcn0RXhCkB2dicg/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" data-report-img-idx="0" data-fail="0" srcset="" referrerpolicy="" class=""></span></section><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-imgfileid="100025753" data-ratio="0.6666666666666666" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdfCDYXlK1DMkxZKUtqeorBfQgvltcL70PojDia00drIRGFiaQohNcvic1A/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-index="2" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdfCDYXlK1DMkxZKUtqeorBfQgvltcL70PojDia00drIRGFiaQohNcvic1A/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" data-report-img-idx="1" data-fail="0" srcset="" referrerpolicy="" class=""></section><p data-pm-slice="0 0 []"><span leaf=""><span textstyle="">为了在朋友圈优雅地假装文艺青年，之前，我用向量数据库Milvus开发了应用</span><span textstyle="">语义搜索古诗词</span><span textstyle="">，它可以把白话文“变成”古诗词（详见</span><a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzUzMDI5OTA5NQ==&amp;mid=2247503136&amp;idx=1&amp;sn=d5faa269d3c862aea9c050e8f39fdb84&amp;scene=21#wechat_redirect" textvalue="" linktype="text" data-linktype="2"><span textstyle="">朋友圈装腔指南：如何用向量数据库把大白话变成古诗词</span></a><span textstyle="">）。</span></span></p><p><span leaf=""><span textstyle="">但是，在朋友圈只发文字未免单调了些，还是需要搭配与古诗词意境相似的图片才行。但是，直接用古诗词检索图片，效果不太理想。</span></span></p><p><span leaf=""><span textstyle="">那么，可以通过向量数据库检索和古诗词含义相近的图片吗？</span></span></p><p><span leaf=""><span textstyle="">答案是当然可以，实现方法和文本的语义检索相似，只不过这次我们要使</span></span><span leaf=""><span textstyle="">用多模态的embedding模型。</span></span></p><p><span leaf=""><span textstyle="">而且，这一套方法，不只能用于古诗文配图，其实也是多数场景（如电商搜索、自动驾驶长尾场景搜寻等）里我们做</span></span><strong><span leaf=""><span textstyle="">文生图、自然语言检索图片的基础操作。</span></span></strong></p><p><strong><span leaf=""><span textstyle="">本文将对如何实现这一系统给出保姆级教程。</span></span></strong></p><section><span data-lark-record-format="docx/record"></span></section><p></p><h2 data-pm-slice="0 0 []"><span leaf=""><span textstyle="">01 多模态embedding模型是如何工作的</span></span></h2><p></p><p><span leaf=""><span textstyle="">纯文本的embedding模型可以根据文本生成向量，语义相近的文本生成的向量，在向量空间的距离相近，而从实现语义检索。如果我想使用文本检索图，比如，用“狗”这个字检索狗的图片，这就需要用到多模态embedding模型。</span></span></p><p><span leaf=""><span textstyle="">如果我们直接把文本向量和图片向量映射到同一个向量空间中，会发现相近概念的向量距离往往并不靠近，所以无法直接比较。而CLIP（Contrastive Language-Image Pre-training） 等embedding模型通过训练，能够让模态（比如文本和图片）不同，但是概念相近的向量，距离也相近。这样，就可以通过文本检索概念相近的图片了。</span></span></p><p><span leaf=""><span textstyle="">那么，CLIP是怎么训练的呢？主要包括以下4个步骤。</span></span></p><p><span leaf=""><span textstyle="">第1步，准备数据集。</span><span textstyle="">训练模型需要使用图文配对的多模态数据集。</span></span></p><p><span leaf=""><span textstyle="">第2步，编码文本和图片</span><span textstyle="">。分别使用文本编码器和图片编码器对文本和图片编码，得到它们的向量。</span></span></p><p><span leaf=""><span textstyle="">第3步，把文本和图片映射到同一空间</span><span textstyle="">。将文本和图片的向量从各自的单模态向量空间投射到同一个多模态向量空间中。换句话说，就是embedding模型根据文本和图片生成相同维度的向量，然后放入同一个向量空间。</span></span></p><p><span leaf=""><span textstyle="">第4步，训练模型</span><span textstyle="">。数据集的结构如下图所示，文本向量和图片向量分布在矩阵的横轴和纵轴上，而且对角线上的文本和图片概念相近。</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="698" data-imgfileid="100025746" data-ratio="0.6370370370370371" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdJbQ0TiajibaojhIibOuNibVUd0AicTPI4mRibM94M8KLMGTcJ7DcVctBGbQw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="3" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdJbQ0TiajibaojhIibOuNibVUd0AicTPI4mRibM94M8KLMGTcJ7DcVctBGbQw/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p><span leaf=""><span textstyle="">图片来源：Learning Transferable Visual Models From Natural Language Supervision</span></span></p><p><span leaf=""><span textstyle="">刚开始，概念相近的文本和图片在向量空间中的距离往往比较远，训练模型的方法，就是拉近概念相近的文本和图片（正样本）的距离，同时推远不同概念（负样本）的距离。</span></span></p><p><span leaf=""><span textstyle="">比如，拉近文本“狗”和狗的图片的距离，而推远“鸟”这个概念（包括文本、图片等）与“狗”的距离。通过这一推一拉，最终让概念相近的文本和图片的向量，在同一个向量空间中越来越靠近。这种使用正反例的训练方法叫做对比学习（contrastive learning）。</span></span></p><p><span leaf=""><span textstyle="">原理了解了，下面我们就来用代码实践一下吧。</span></span></p><p></p><h2><span leaf=""><span textstyle="">02 手把手实践</span></span></h2><h2><span leaf=""><span textstyle="">（1）准备工作</span></span></h2><p></p><p><span leaf=""><span textstyle="">首先安装Milvus和pymilvus包，这里不再赘述，版本建议：Milvus 版本&gt;=2.5.0，pymilvus 版本&gt;=2.5.0。</span></span></p><p><span leaf=""><span textstyle="">然后安装CLIP的中文微调版Chinese-CLIP。</span></span></p><p><span leaf=""><span textstyle="">安装方法1：通过pip安装。</span></span></p><p></p><pre><code data-lark-language="Bash" data-wrap="false"><section><ul class="has-li"><li></li></ul><pre data-lang="nginx"><code><span leaf=""><span>pip</span>&nbsp;install cn_clip</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">安装方法2：下载Chinese-CLIP，从源代码安装。</span></span></p><p></p><pre><code data-lark-language="Bash" data-wrap="false"><section><ul class="has-li"><li></li><li></li></ul><pre data-lang="bash"><code><span leaf=""><span>cd</span>&nbsp;Chinese-CLIP</span></code><code><span leaf="">!pip install -e .</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">最后下载Landscapes HQ dataset数据集。LHQ1024_jpg共有90000张图片，为了方便演示，文本只使用了前5000张。在这里下载，提取码: 7d88。</span></span></p><p><span leaf=""><span textstyle="">下载后解压，里面有图片query_image.jpg和文件夹lhq_1024_jpg_5000，这是后面需要用到的图片数据集。还有一个文件夹chinese_clip_model，里面放的是后面要用到的多模态embedding模型clip_cn_vit-b-16.pt，这是为了避免因为网络问题无法下载，所以提前准备了。</span></span></p><p></p><h2><span leaf=""><span textstyle="">（2）创建集合</span></span></h2><p></p><p><span leaf=""><span textstyle="">首先创建模式，需要3个字段，id表示图片的唯一标识符，vectors表示图片的向量，filepath则是图片的路径。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 创建模式</span></span></code><code><span leaf=""><span>from</span>&nbsp;pymilvus&nbsp;<span>import</span>&nbsp;MilvusClient, DataType</span></code><code><span leaf=""><span>import</span>&nbsp;torch</span></code><code><span leaf=""><span>import</span>&nbsp;time</span></code><code><span leaf="">milvus_client = MilvusClient(uri=<span>"http://localhost:19530"</span>)</span></code><code><span leaf=""><span>def</span>&nbsp;<span>create_schema</span>():</span></code><code><span leaf="">&nbsp; &nbsp; schema = milvus_client.create_schema(</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; auto_id=<span>True</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; enable_dynamic_field=<span>True</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; description=<span>""</span></span></code><code><span leaf="">&nbsp; &nbsp; )</span></code><code><span leaf="">&nbsp; &nbsp; schema.add_field(field_name=<span>"id"</span>, datatype=DataType.INT64, descrition=<span>'ids'</span>, is_primary=<span>True</span>)</span></code><code><span leaf="">&nbsp; &nbsp; schema.add_field(field_name=<span>"vectors"</span>, datatype=DataType.FLOAT_VECTOR, descrition=<span>'embedding vectors'</span>, dim=<span>512</span>)</span></code><code><span leaf="">&nbsp; &nbsp; schema.add_field(field_name=<span>"filepath"</span>, datatype=DataType.VARCHAR, descrition=<span>'file path'</span>, max_length=<span>200</span>)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;schema</span></code><code><span leaf="">schema = create_schema()</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">接下来定义一个创建集合的函数。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 定义创建集合的函数</span></span></code><code><span leaf=""><span>import</span>&nbsp;time</span></code><code><span leaf=""><span>def</span>&nbsp;<span>create_collection</span>(<span>collection_name, schema, timeout =&nbsp;</span><span><span>3</span></span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 创建集合</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>try</span>:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; milvus_client.create_collection(</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection_name=collection_name,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schema=schema,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shards_num=<span>2</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; )</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"开始创建集合：</span><span><span>{collection_name}</span></span><span>"</span>)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>except</span>&nbsp;Exception&nbsp;<span>as</span>&nbsp;e:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"创建集合的过程中出现了错误:&nbsp;</span><span><span>{e}</span></span><span>"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;<span>False</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 检查集合是否创建成功</span></span></code><code><span leaf="">&nbsp; &nbsp; start_time = time.time()</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>while</span>&nbsp;<span>True</span>:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>if</span>&nbsp;milvus_client.has_collection(collection_name):</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"集合&nbsp;</span><span><span>{collection_name}</span></span><span>&nbsp;创建成功"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;<span>True</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>elif</span>&nbsp;time.time() - start_time &gt; timeout:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"创建集合&nbsp;</span><span><span>{collection_name}</span></span><span>&nbsp;超时"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;<span>False</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; time.sleep(<span>1</span>)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">为了避免集合重名导致冲突，创建集合前先删除同名集合。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 定义检查并且删除同名集合的函数</span></span></code><code><span leaf=""><span>class</span>&nbsp;<span>CollectionDeletionError</span>(<span>Exception</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>""${'"'}删除集合失败""${'"'}</span></span></code><code><span leaf=""><span>def</span>&nbsp;<span>check_and_drop_collection</span>(<span>collection_name</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>if</span>&nbsp;milvus_client.has_collection(collection_name):</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"集合&nbsp;</span><span><span>{collection_name}</span></span><span>&nbsp;已经存在"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>try</span>:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; milvus_client.drop_collection(collection_name)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"删除集合：</span><span><span>{collection_name}</span></span><span>"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;<span>True</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>except</span>&nbsp;Exception&nbsp;<span>as</span>&nbsp;e:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"删除集合时出现错误:&nbsp;</span><span><span>{e}</span></span><span>"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;<span>False</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;<span>True</span></span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">创建集合。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="makefile"><code><span leaf="">collection_name =&nbsp;<span>"multimodal_chinese_clip"</span></span></code><code><span leaf="">uri=<span>"http://localhost:19530"</span></span></code><code><span leaf="">milvus_client = MilvusClient(uri=uri)</span></code><code><span leaf=""><span># 如果无法删除集合，抛出异常</span></span></code><code><span leaf="">if not check_and_drop_collection(collection_name):</span></code><code><span leaf="">&nbsp; &nbsp; raise CollectionDeletionError('删除集合失败')</span></code><code><span leaf=""><span>else:</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 创建集合的模式</span></span></code><code><span leaf="">&nbsp; &nbsp; schema = create_schema()</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 创建集合并等待成功</span></span></code><code><span leaf="">&nbsp; &nbsp; create_collection(collection_name, schema)</span></code></pre></section></code></pre><h2><span leaf=""><span textstyle="">（3）定义向量化函数</span></span></h2><p></p><p><span leaf=""><span textstyle="">集合创建完成后，接下来就是把数据集中的图片向量化，插入Milvus。向量化需要使用embedding模型，Chinese-CLIP包含多个embedding模型，查看方法如下：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span>import</span>&nbsp;cn_clip.clip&nbsp;<span>as</span>&nbsp;clip &nbsp;</span></code><code><span leaf=""><span># 导入可用模型的函数</span></span></code><code><span leaf=""><span>from</span>&nbsp;cn_clip.clip&nbsp;<span>import</span>&nbsp;available_models</span></code><code><span leaf=""><span>import</span>&nbsp;torch</span></code><code><span leaf=""><span># 用于图片处理</span></span></code><code><span leaf=""><span>from</span>&nbsp;PIL&nbsp;<span>import</span>&nbsp;Image</span></code><code><span leaf=""><span># 查看 chinese-clip 中可用模型列表</span></span></code><code><span leaf=""><span>print</span>(<span>"Available models:"</span>, available_models())</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">输出：</span></span></p><p></p><pre><code data-lark-language="Plain Text" data-wrap="false"><section><ul class="has-li"><li></li></ul><pre data-lang="nginx"><code><span leaf=""><span>Available</span>&nbsp;models: [<span>'ViT-B-16'</span>,&nbsp;<span>'ViT-L-14'</span>,&nbsp;<span>'ViT-L-14-336'</span>,&nbsp;<span>'ViT-H-14'</span>,&nbsp;<span>'RN50'</span>]</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">Chinese-CLIP的embedding模型分成ViT（Vision Transformer）架构和RN（ResNet）架构两种。</span></span></p><p><span leaf=""><span textstyle="">先介绍ViT系列模型，它的命名规律是，ViT-{参数规模}-{patch大小}-{输入图片分辨率}。第1个参数“ViT”表示模型的架构，第2个参数表示模型的参数规模，分成B（Base，中等规模）、L（Large，大规模）和H（Huge，超大规模），让我想起咖啡的中杯、大杯和超大杯。第3个参数指的是图片被分割成的patch的大小，14表示patch的尺寸是14 * 14像素。embedding模型在处理图片时，会先把图片分割成多个patch，类似于处理文本时，先对文本分块（详见[[03-鲁迅到底说没说？RAG之分块]]）。输入图片的分辨率默认为224 * 224像素，否则会通过第4个参数指定。</span></span></p><p><span leaf=""><span textstyle="">举个例子，“ViT-L-14-336”表示该embedding模型是ViT架构，参数规模为大规模，patch的尺寸是14 * 14，输入图片的分辨率是336 * 336。</span></span></p><p><span leaf=""><span textstyle="">相比于ViT系列模型，RN系列模型的命名规律简单些：RN+层数。第1个参数“RN”同样表示模型架构，第2个参数表示层数。比如，RN50表示该模型基于50层的ResNet架构。</span></span></p><p><span leaf=""><span textstyle="">为了方便演示，我们使用较小的“ViT-B-16”模型。通过clip.load_from_name函数下载、加载模型和预处理函数。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 确定使用的设备：如果可用则使用GPU，否则使用CPU</span></span></code><code><span leaf="">device =&nbsp;<span>"cuda"</span>&nbsp;<span>if</span>&nbsp;torch.cuda.is_available()&nbsp;<span>else</span>&nbsp;<span>"cpu"</span></span></code><code><span leaf=""><span># 指定模型名称</span></span></code><code><span leaf="">model_name =&nbsp;<span>"ViT-B-16"</span></span></code><code><span leaf=""><span># 加载chinese-clip模型和对应的预处理函数</span></span></code><code><span leaf=""><span># model: 包含图片编码器（encode_image）和文本编码器（encode_text）</span></span></code><code><span leaf=""><span># preprocess: 图片预处理函数（包括归一化、缩放等操作）</span></span></code><code><span leaf=""><span># download_root: 设置模型下载后保存的位置</span></span></code><code><span leaf="">model, preprocess = clip.load_from_name(model_name, device=device, download_root=<span>'./chinese_clip_model'</span>)</span></code><code><span leaf=""><span># 将模型设置为评估模式，关闭dropout等训练特性</span></span></code><code><span leaf="">model.<span>eval</span>()</span></code><code><span leaf=""><span>print</span>(<span>"-"</span>*<span>50</span>)</span></code><code><span leaf=""><span>print</span>(<span>f"Model Loaded:&nbsp;</span><span><span>{model_name}</span></span><span>"</span>)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">加载好embedding模型后，就可以调用它们定义向量化图片和文本的函数了。定义向量化图片的函数如下所示：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span>def</span>&nbsp;<span>encode_image</span>(<span>image_path</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 关闭梯度计算，减少内存消耗，提高计算效率</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>with</span>&nbsp;torch.no_grad():</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 打开图片文件</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 如果图片不是RGB格式，使用convert转换格式</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; raw_image = Image.<span>open</span>(image_path).convert(<span>'RGB'</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; processed_image = preprocess(raw_image).unsqueeze(<span>0</span>).to(device)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 生成图片的向量</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; image_features = model.encode_image(processed_image)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 特征归一化</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; image_features /= image_features.norm(dim=-<span>1</span>, keepdim=<span>True</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 以列表形式返回向量</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;image_features.squeeze().tolist()</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">定义向量化文本的函数如下所示：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span>def</span>&nbsp;<span>encode_text</span>(<span>text_list</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 关闭梯度计算，减少内存消耗，提高计算效率</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>with</span>&nbsp;torch.no_grad():</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 文本分词和特殊符号处理</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; text_tokens = clip.tokenize(text_list).to(device)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 生成文本的向量</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; text_features = model.encode_text(text_tokens)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 特征归一化</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; text_features /= text_features.norm(dim=-<span>1</span>, keepdim=<span>True</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 以列表形式返回向量</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;[f.squeeze().tolist()&nbsp;<span>for</span>&nbsp;f&nbsp;<span>in</span>&nbsp;text_features]</span></code></pre></section></code></pre><h2><span leaf=""><span textstyle="">（4）插入数据</span></span></h2><p></p><p><span leaf=""><span textstyle="">接下来，调用上一步中定义的函数，分批次把图片向量化并且插入到Milvus中。插入数据的函数如下所示：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 定义插入数据的函数</span></span></code><code><span leaf=""><span>import</span>&nbsp;os</span></code><code><span leaf=""><span>from</span>&nbsp;glob&nbsp;<span>import</span>&nbsp;glob</span></code><code><span leaf=""><span>from</span>&nbsp;tqdm&nbsp;<span>import</span>&nbsp;tqdm</span></code><code><span leaf=""><span>import</span>&nbsp;time</span></code><code><span leaf=""><span># 进度条显示一个变化的进度条，而不是多个不同进度的进度条</span></span></code><code><span leaf=""><span>def</span>&nbsp;<span>process_images_and_insert</span>(<span>input_dir_path, ext_list, batch_size=</span><span><span>100</span></span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 获取所有JPEG文件路径（递归图片检索）</span></span></code><code><span leaf="">&nbsp; &nbsp; image_paths = []</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>for</span>&nbsp;ext&nbsp;<span>in</span>&nbsp;ext_list:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; image_paths.extend(glob(os.path.join(input_dir_path,&nbsp;<span>f"**/</span><span><span>{ext}</span></span><span>"</span>), recursive=<span>True</span>))</span></code><code><span leaf="">&nbsp; &nbsp; total_images =&nbsp;<span>len</span>(image_paths)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"总计需要处理&nbsp;</span><span><span>{total_images}</span></span><span>&nbsp;张图片"</span>)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 初始化总计时器</span></span></code><code><span leaf="">&nbsp; &nbsp; total_start_time = time.time()</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 初始化进度条</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>with</span>&nbsp;tqdm(total=total_images, desc=<span>"处理图片并插入数据"</span>)&nbsp;<span>as</span>&nbsp;progress_bar:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 分批处理图片</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>for</span>&nbsp;batch_start&nbsp;<span>in</span>&nbsp;<span>range</span>(<span>0</span>, total_images, batch_size):</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_data = []</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_paths = image_paths[batch_start: batch_start + batch_size]</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_start_time = time.time()</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 当前批次的向量化处理</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>for</span>&nbsp;image_path&nbsp;<span>in</span>&nbsp;batch_paths:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>try</span>:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; image_embedding = encode_image(image_path)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_data.append({</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>"vectors"</span>: image_embedding,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>"filepath"</span>: image_path</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>except</span>&nbsp;Exception&nbsp;<span>as</span>&nbsp;e:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"处理图片&nbsp;</span><span><span>{image_path}</span></span><span>&nbsp;时出错:&nbsp;</span><span><span>{</span></span><span><span><span>str</span></span></span><span><span>(e)}</span></span><span>"</span>)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>continue</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 批量插入当前批次到Milvus</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>if</span>&nbsp;batch_data:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>try</span>:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = milvus_client.insert(</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection_name=collection_name,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data=batch_data</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 计算批次耗时</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_duration = time.time() - batch_start_time</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 更新进度条：每次成功插入的图片数量</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; progress_bar.update(<span>len</span>(batch_data))</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 显示批次处理时间</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; progress_bar.set_postfix({</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>"批次耗时"</span>: batch_duration,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }) &nbsp;</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>except</span>&nbsp;Exception&nbsp;<span>as</span>&nbsp;e:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"插入批次&nbsp;</span><span><span>{batch_start}</span></span><span>&nbsp;时失败:&nbsp;</span><span><span>{</span></span><span><span><span>str</span></span></span><span><span>(e)}</span></span><span>"</span>) &nbsp; &nbsp;</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 计算总耗时</span></span></code><code><span leaf="">&nbsp; &nbsp; total_duration = time.time() - total_start_time</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"\n所有图片处理完成！总耗时: total_duration)"</span>)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>print</span>(<span>f"平均处理速度:&nbsp;</span><span><span>{total_images/total_duration:</span></span><span><span><span>.1</span></span></span><span><span>f}</span></span><span>张/秒"</span>)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">分批插入数据：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="nginx"><code><span leaf=""><span># 插入数据</span></span></code><code><span leaf=""><span>input_dir_path</span>&nbsp;=&nbsp;<span>"lhq_1024_jpg_5000"</span></span></code><code><span leaf=""><span># 每批处理数量</span></span></code><code><span leaf="">batch_size =&nbsp;<span>300</span></span></code><code><span leaf="">ext_list = [<span>'*.JPEG'</span>,&nbsp;<span>'*.jpg'</span>,&nbsp;<span>'*.png'</span>]</span></code><code><span leaf="">process_images_and_insert(input_dir_path, ext_list, batch_size)</span></code></pre></section></code></pre><h2><span leaf=""><span textstyle="">(5)创建索引并且加载集合</span></span></h2><p></p><p><span leaf=""><span textstyle="">数据插入成功后，还需要创建索引。使用倒排索引（IVF_FLAT），检索效率高，准确性也不错。度量方式使用余弦相似度（COSINE）。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 定义创建索引的函数</span></span></code><code><span leaf=""><span>def</span>&nbsp;<span>create_index</span>(<span>collection_name</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 准备索引参数</span></span></code><code><span leaf="">&nbsp; &nbsp; index_params = milvus_client.prepare_index_params()</span></code><code><span leaf="">&nbsp; &nbsp; index_params.add_index(</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; index_name=<span>"IVF_FLAT"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 指定创建索引的字段</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; field_name=<span>"vectors"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; index_type=<span>"IVF_FLAT"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; metric_type=<span>"COSINE"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; params={<span>"nlist"</span>:<span>512</span>}</span></code><code><span leaf="">&nbsp; &nbsp; )</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 创建索引</span></span></code><code><span leaf="">&nbsp; &nbsp; milvus_client.create_index(</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; collection_name=collection_name,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; index_params=index_params</span></code><code><span leaf="">&nbsp; &nbsp; )</span></code><code><span leaf="">create_index(collection_name)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">索引创建完成后，需要把集合加载到内存中，这样才能检索。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"></code></pre><p></p><section><pre data-lang="python"><code><span leaf=""><span># 加载集合</span></span></code><code><span leaf=""><span>print</span>(<span>f"正在加载集合&nbsp;</span><span><span>{collection_name}</span></span><span>"</span>)</span></code><code><span leaf="">milvus_client.load_collection(collection_name=collection_name)</span></code><code><span leaf=""><span>print</span>(<span>f"集合&nbsp;</span><span><span>{collection_name}</span></span><span>&nbsp;加载完成"</span>)</span></code></pre></section><p><span leaf=""><span textstyle="">集合加载成功了吗？验证下看看。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="perl"><code><span leaf=""><span># 验证加载状态</span></span></code><code><span leaf=""><span>state</span>&nbsp;= str(milvus_client.get_load_state(collection_name=collection_name)[<span>'state'</span>])</span></code><code><span leaf=""><span>if</span>&nbsp;<span>state</span>&nbsp;==&nbsp;<span>'Loaded'</span>:</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>print</span>(<span>"集合加载完成"</span>)</span></code><code><span leaf=""><span>else</span>:</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>print</span>(<span>"集合加载失败"</span>)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">数据集中有5000条数据，查看集合中的数据数量是否正确。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="bash"><code><span leaf=""><span>print</span>(milvus_client.query(</span></code><code><span leaf="">&nbsp; &nbsp; collection_name=collection_name,</span></code><code><span leaf="">&nbsp; &nbsp; output_fields=[<span>"count(*)"</span>]</span></code><code><span leaf="">&nbsp; &nbsp; )</span></code><code><span leaf="">)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">如果一切正常，返回内容应该是这样的：</span></span></p><p></p><pre><code data-lark-language="Plain Text" data-wrap="false"><section><ul class="has-li"><li></li></ul><pre data-lang="powershell"><code><span leaf=""><span>data</span>: [<span>"{'count(*)': 5000}"</span>]</span></code></pre></section></code></pre><h2><span leaf=""><span textstyle="">03 结果展示</span></span></h2><p></p><p><span leaf=""><span textstyle="">使用Chinese-CLIP可以实现以文搜图以及以图搜图，其实本质都是相同的，都是根据查询（文字或者图片）生成查询向量，再从Milvus中检索与查询向量最接近的图片的向量，最后返回该图片。先来试试以文搜图吧。</span></span></p><p></p><h3><span leaf=""><span textstyle="">以文搜图</span></span></h3><p></p><p><span leaf=""><span textstyle="">首先定义图片检索函数。输入查询向量（vector）、图片检索的字段（field_name）、返回结果的数量（limit）以及输出的字段（output_fields），返回图片检索结果。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="bash"><code><span leaf=""><span># 定义图片检索函数</span></span></code><code><span leaf="">def vector_search(vector, field_name,&nbsp;<span>limit</span>, output_fields):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 执行向量图片检索</span></span></code><code><span leaf="">&nbsp; &nbsp; res = milvus_client.search(</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; collection_name=collection_name,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; data=vector,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; anns_field=field_name,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>limit</span>=<span>limit</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; output_fields=output_fields</span></code><code><span leaf="">&nbsp; &nbsp; )</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;res</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">然后就可以检索了。以马致远的《天净沙·秋思》为例，看看分别能检索出什么图片。先开看看第一句，“枯藤老树昏鸦”。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="ini"><code><span leaf=""><span># 以文搜图</span></span></code><code><span leaf=""><span>query_text</span>&nbsp;= [<span>"枯藤老树昏鸦"</span>]</span></code><code><span leaf=""><span>query_embedding</span>&nbsp;= encode_text(query_text)[<span>0</span>]</span></code><code><span leaf=""><span>field_name</span>&nbsp;=&nbsp;<span>"vectors"</span></span></code><code><span leaf=""><span>limit</span>&nbsp;=&nbsp;<span>10</span></span></code><code><span leaf=""><span>output_fields</span>&nbsp;= [<span>"filepath"</span>]</span></code><code><span leaf=""><span>res</span>&nbsp;= vector_search([query_embedding], field_name, limit, output_fields)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">得到检索结果后，还需要定义一个显示图片检索结果（也就是图片）的函数，方便查看。</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span>from</span>&nbsp;IPython.display&nbsp;<span>import</span>&nbsp;display</span></code><code><span leaf=""><span>from</span>&nbsp;PIL&nbsp;<span>import</span>&nbsp;Image</span></code><code><span leaf=""><span># 定义显示图片检索结果的函数</span></span></code><code><span leaf=""><span>def</span>&nbsp;<span>create_concatenated_image</span>(<span>res, images_per_row=</span><span><span>2</span></span><span>, images_per_column=</span><span><span>2</span></span><span>, image_size=(</span><span><span><span>400</span></span></span><span><span>,&nbsp;</span></span><span><span><span>400</span></span></span><span>)</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 设置拼接后的大图尺寸：</span></span></code><code><span leaf="">&nbsp; &nbsp; width = image_size[<span>0</span>] * images_per_row</span></code><code><span leaf="">&nbsp; &nbsp; height = image_size[<span>1</span>] * images_per_column</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 创建一个空白的大画布（RGB模式，白色背景）</span></span></code><code><span leaf="">&nbsp; &nbsp; concatenated_image = Image.new(<span>"RGB"</span>, (width, height))</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 存储所有结果图片的列表</span></span></code><code><span leaf="">&nbsp; &nbsp; result_images = []</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 遍历图片检索结果的每个hit对象（res是包含多个batch的列表）</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>for</span>&nbsp;result&nbsp;<span>in</span>&nbsp;res: &nbsp;<span># 通常res是单batch列表</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>for</span>&nbsp;hit&nbsp;<span>in</span>&nbsp;result:</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 从hit对象中获取图片文件路径</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename = hit[<span>"entity"</span>][<span>"filepath"</span>]</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 打开图片文件并调整大小为指定尺寸</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; img = Image.<span>open</span>(filename)</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 保持宽高比的缩略图</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; img = img.resize(image_size) &nbsp;</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 将处理后的图片添加到列表</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_images.append(img) &nbsp;</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 将缩略图拼接到大画布上</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>for</span>&nbsp;idx, img&nbsp;<span>in</span>&nbsp;<span>enumerate</span>(result_images):</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 计算当前图片应放置的网格位置：</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 列索引（每行显示images_per_row张图）</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; x = idx % images_per_row</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 行索引（整数除法）&nbsp;</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; y = idx // images_per_row</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span># 将图片粘贴到计算好的位置</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; concatenated_image.paste(img, (x * image_size[<span>0</span>], y * image_size[<span>1</span>]))</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span>return</span>&nbsp;concatenated_image</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">执行该函数，查看检索结果：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="apache"><code><span leaf=""><span># 查询文本</span></span></code><code><span leaf=""><span>print</span>(f<span>"查询文本: {query_text}"</span>)</span></code><code><span leaf=""><span># 图片检索结果</span></span></code><code><span leaf=""><span>print</span>(f<span>"检索结果："</span>)</span></code><code><span leaf=""><span>display</span>(create_concatenated_image(res,&nbsp;<span>2</span>,&nbsp;<span>2</span>, (<span>400</span>,&nbsp;<span>400</span>)))</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">返回的结果应该是这样的：</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="1130" data-imgfileid="100025747" data-ratio="1.0314814814814814" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd9H9nex6AWFFiahQTyIaKHvNicqrnxrlxa1uWlibjamoFX7cqaQtqL1NJA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="4" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd9H9nex6AWFFiahQTyIaKHvNicqrnxrlxa1uWlibjamoFX7cqaQtqL1NJA/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p><span leaf=""><span textstyle="">我觉得这些图片的意境还蛮符合的，你觉得怎么样？我们再来试试其他句子，检索“小桥流水人家”：</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="1132" data-imgfileid="100025750" data-ratio="1.0324074074074074" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd1khJQb7lPJFYZPo9pds0D0v9LItxNNc8m3iaXn2Z97Q6bCScJTp6Fag/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="5" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd1khJQb7lPJFYZPo9pds0D0v9LItxNNc8m3iaXn2Z97Q6bCScJTp6Fag/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p><span leaf=""><span textstyle="">检索“古道西风瘦马”：</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="1124" data-imgfileid="100025749" data-ratio="1.025925925925926" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd4E6ibMyEkGVTZU7ZQA5eAtibydUksQuEF55lSrXlIIXtzpNjUI36dFdQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="6" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd4E6ibMyEkGVTZU7ZQA5eAtibydUksQuEF55lSrXlIIXtzpNjUI36dFdQ/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p><span leaf=""><span textstyle="">检索“夕阳西下”：</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="1112" data-imgfileid="100025748" data-ratio="1.0148148148148148" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdiaFbbXlj1yWPfUowhy3PjIxqtTNBsribGHIw3rEDLyAibMUcS1gcLVticQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="7" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdiaFbbXlj1yWPfUowhy3PjIxqtTNBsribGHIw3rEDLyAibMUcS1gcLVticQ/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p><span leaf=""><span textstyle="">检索“断肠人在天涯”：</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="1128" data-imgfileid="100025751" data-ratio="1.0296296296296297" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd9OT8sicWlEEGZjb2us2SFRlztfI1LzFtpHZQ3oQHVria7WZeDt7uMia1A/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="8" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVd9OT8sicWlEEGZjb2us2SFRlztfI1LzFtpHZQ3oQHVria7WZeDt7uMia1A/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p><span leaf=""><span textstyle="">说实话，我对后半段的检索结果并不是十分满意，比如“古道西风瘦马”里面没有马，“断肠人在天涯”中也没有人。</span></span></p><p><span leaf=""><span textstyle="">为什么会这样？</span></span></p><p><span leaf=""><span textstyle="">有多个原因会导致这样的结果，比如数据集没根本就没有和查询概念相近的图片，还有可能是embedding模型没有的文本和图片编码器的特征空间没有充分对齐，也就是说概念相近的文本和图片生成的向量，在向量空间中的距离并不靠近。这种情况需要提供更多数据来做微调。</span></span></p><p></p><h3><span leaf=""><span textstyle="">以图搜图</span></span></h3><p></p><p><span leaf=""><span textstyle="">尝试了以文搜图，再来试试以图搜图吧。我随手拍了一张夕阳西下的照片作为查询。为了显示查询内容，还需要定义一个显示查询图片的函数show_single_image：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="python"><code><span leaf=""><span># 显示查询图片</span></span></code><code><span leaf=""><span>def</span>&nbsp;<span>show_single_image</span>(<span>image_path, image_size=(</span><span><span><span>300</span></span></span><span><span>,&nbsp;</span></span><span><span><span>300</span></span></span><span>)</span>):</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 打开图片</span></span></code><code><span leaf="">&nbsp; &nbsp; img = Image.<span>open</span>(image_path)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 保持宽高比的前提下缩小图片，图片缩小后的最大值不超过指定值</span></span></code><code><span leaf="">&nbsp; &nbsp; img.thumbnail(image_size)</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 缩放图片到指定尺寸</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># img = img.resize(image_size)</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span># 显示图片</span></span></code><code><span leaf="">&nbsp; &nbsp; display(img)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">检索与查询图片相似的图片：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="ini"><code><span leaf=""><span># 定义查询图片</span></span></code><code><span leaf=""><span>query_image</span>&nbsp;=&nbsp;<span>'query_image.jpg'</span></span></code><code><span leaf=""><span>query_embedding</span>&nbsp;= encode_image(query_image)</span></code><code><span leaf=""><span>field_name</span>&nbsp;=&nbsp;<span>"vectors"</span></span></code><code><span leaf=""><span>limit</span>&nbsp;=&nbsp;<span>10</span></span></code><code><span leaf=""><span>output_fields</span>&nbsp;= [<span>"filepath"</span>]</span></code><code><span leaf=""><span>res</span>&nbsp;= vector_search([query_embedding], field_name, limit, output_fields)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">显示检索结果：</span></span></p><p></p><pre><code data-lark-language="Python" data-wrap="false"><section><ul class="has-li"><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang="bash"><code><span leaf=""><span># 查询图片</span></span></code><code><span leaf=""><span>print</span>(f<span>"查询图片"</span>)</span></code><code><span leaf="">show_single_image(query_image)</span></code><code><span leaf=""><span># 图片检索结果</span></span></code><code><span leaf=""><span>print</span>(f<span>"图片检索结果："</span>)</span></code><code><span leaf="">concatenated_image = create_concatenated_image(res)</span></code><code><span leaf="">display(concatenated_image)</span></code></pre></section></code></pre><p></p><p><span leaf=""><span textstyle="">虽然返回的图片与之前用文本“夕阳西下”搜索的结果并不相同，但整体画面内容仍然相近。</span></span></p><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" data-height="1528" data-imgfileid="100025752" data-ratio="1.3944444444444444" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdQlsDb2ymJ7GsS64nhUWwUXRJC3nFHv09wAjWZm7XQ2ElGkyFbGR2YQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-width="1096" data-index="9" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh7jGWQr4QxdpsFNTP22IFVdQlsDb2ymJ7GsS64nhUWwUXRJC3nFHv09wAjWZm7XQ2ElGkyFbGR2YQ/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></section><p></p><h2><span leaf=""><span textstyle="">04 总结</span></span></h2><p></p><p><span leaf=""><span textstyle="">和单一模态的embedding模型相比，</span><span textstyle="">多模态embedding模型可以同时处理多种类型的数据</span><span textstyle="">。除了以文搜图，我们还能实现以文搜视频，以图搜视频等等方式。</span></span></p><p><span leaf=""><span textstyle="">这对多数企业来说意义非凡。长期来看，企业掌握的数据早已不再局限于过去的结构化报表。</span><span textstyle="">合同、客服通话、监控视频、设计图纸、培训录音——90% 以上的企业数据都是非结构化的。</span></span></p><p><span leaf=""><span textstyle="">自然语言查询（Natural Language Query）与多模态 embedding 模型的兴起，提供了处理非结构化数据的解决路径</span><span textstyle="">。前者让用户可以用自然语言向系统提问，极大降低了数据使用门槛。而后者则进一步打破了文本、图像、音频等数据孤岛，实现真正的语义级理解与搜索。</span></span></p><p><span leaf=""><span textstyle="">未来，无论是合规团队想查询“最近半年所有涉及 ESG 风险的合同条款”，还是产品经理希望定位“用户提到‘卡顿’但未使用关键词‘卡慢’的视频录屏”，都可以通过一句话完成调用。</span></span></p><p><span leaf=""><span textstyle="">这不仅是一次搜索体验的升级，更是组织知识管理范式的转变。</span></span></p><section data-pm-slice="0 0 []"><p><span><strong><span leaf=""><span textstyle="">作者介绍</span></span></strong></span></p></section><section><section><svg viewBox="0 0 1 1" style="display: none;"></svg></section><section nodeleaf=""><img loading="lazy" style="width: 140px !important;" alt="图片" data-backh="195" data-backw="195" data-imgfileid="100020490" data-ratio="1" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/MqgA8Ylgeh611GeZjjM3ethCDUf2eHRZLPHgNfPRseLB89jCZxS0RgXibaQt3lgsxzsRK1RGsicvLedj7wuibbGSw/640?wx_fmt=jpeg&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" data-type="jpeg" data-w="940" data-index="10" src="https://mmbiz.qpic.cn/mmbiz_jpg/MqgA8Ylgeh611GeZjjM3ethCDUf2eHRZLPHgNfPRseLB89jCZxS0RgXibaQt3lgsxzsRK1RGsicvLedj7wuibbGSw/640?wx_fmt=jpeg&amp;from=appmsg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" _width="185.398px" srcset="" referrerpolicy="" class=""></section><section><svg viewBox="0 0 1 1" style="display: none;"></svg></section></section><section><p><span><span><span leaf=""><span textstyle="">Zilliz 黄金写手：</span></span></span><span leaf=""><span textstyle="">江浩</span></span></span></p></section><section><span><span leaf=""><span textstyle="">推荐阅读</span></span></span></section><section><span><span leaf=""><a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzUzMDI5OTA5NQ==&amp;mid=2247493961&amp;idx=1&amp;sn=b4e4c157dec563dfa96e82b1bd952192&amp;forceh5=1&amp;scene=21#wechat_redirect" textvalue="从零到一，教你搭建「以文搜图」搜索服务（一）" data-itemshowtype="0" linktype="text" data-linktype="2"><span textstyle="">从零到一，教你搭建「以文搜图」搜索服务（一）</span></a></span></span></section><section><span><span leaf=""><a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzUzMDI5OTA5NQ==&amp;mid=2247493992&amp;idx=1&amp;sn=318a993e684ea4c0ebdcc0a7e7a6c4d4&amp;chksm=fa5148d0cd26c1c6ee1a6601b9b2a48da783a544d4aebebeaf4525b5145c4afe85fb6076b958&amp;cur_album_id=2451549859255287814&amp;scene=21#wechat_redirect" textvalue="从零到一，教你搭建「CLIP 以文搜图」搜索服务（二）：5 分钟实现原型" data-itemshowtype="0" linktype="text" data-linktype="2"><span textstyle="">从零到一，教你搭建「CLIP 以文搜图」搜索服务（二）：5 分钟实现原型</span></a></span></span></section><section><span><span leaf=""><a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzUzMDI5OTA5NQ==&amp;mid=2247503735&amp;idx=1&amp;sn=8ec47231dca1ecc886ef4b06ecae108d&amp;scene=21#wechat_redirect" textvalue="手把手系列丨如何利用 Milvus 实现多模态搜索" data-itemshowtype="0" linktype="text" data-linktype="2"><span textstyle="">手把手系列丨如何利用 Milvus 实现多模态搜索</span></a></span></span></section><section><span><span leaf=""><a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzUzMDI5OTA5NQ==&amp;mid=2247509201&amp;idx=1&amp;sn=7131c6f85f46eeb3d7265025c1f45b46&amp;scene=21#wechat_redirect" textvalue="Response指南：为什么90%的多模态RAG，一做就会，一用就废？" data-itemshowtype="0" linktype="text" data-linktype="2"><span textstyle="">Response指南：为什么90%的多模态RAG，一做就会，一用就废？</span></a></span></span></section><section><span leaf=""><img loading="lazy" style="width: 140px !important;" data-imgfileid="100025688" data-ratio="0.5259259259259259" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh5OzgygOxg4CIjUuFvGuMfcFUuOJwfp2fe1pg50tjrAWF5C9TzVKFt2D98sGjguIcPEI3TCcMPrDQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-index="11" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh5OzgygOxg4CIjUuFvGuMfcFUuOJwfp2fe1pg50tjrAWF5C9TzVKFt2D98sGjguIcPEI3TCcMPrDQ/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></span></section><p><span leaf=""><img loading="lazy" style="width: 140px !important;" data-imgfileid="100025600" data-ratio="0.2537037037037037" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh4ek0GU1Snpd5xyiahZAUvz7DbjIGcGrDrbxqVsqlzTMhllbNJR9UIE3QF35qrwNmAkv9wW1gEcK6A/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" data-index="12" src="https://mmbiz.qpic.cn/mmbiz_png/MqgA8Ylgeh4ek0GU1Snpd5xyiahZAUvz7DbjIGcGrDrbxqVsqlzTMhllbNJR9UIE3QF35qrwNmAkv9wW1gEcK6A/640?wx_fmt=png&amp;from=appmsg" _width="677px" alt="Image" srcset="" referrerpolicy="" class=""></span></p><p></p></div></div>
"""